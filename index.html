<!DOCTYPE html>
<html lang="si">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>‡∑É‡∑í‡∂Ç‡∑Ñ‡∂Ω ‡∂∂‡∑î‡∂Ø‡∑ä‡∂∞‡∑í‡∂∏‡∂≠‡∑ä ‡∑É‡∑ô‡∑Ä‡∑î‡∂∏</title>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Sinhala&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Noto Sans Sinhala', sans-serif;
      background: #f4f6f8;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      margin: 0;
    }
    h1 {
      color: #2c3e50;
      margin-bottom: 20px;
    }
    #search-box {
      display: flex;
      width: 100%;
      max-width: 600px;
      margin-bottom: 30px;
      gap: 5px;
    }
    #query {
      flex: 1;
      padding: 12px 20px;
      font-size: 18px;
      border: 2px solid #3498db;
      border-radius: 10px;
      outline: none;
    }
    button {
      padding: 12px 20px;
      font-size: 18px;
      background-color: #3498db;
      color: white;
      border: 2px solid #3498db;
      border-radius: 10px;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    button:hover {
      background-color: #2980b9;
    }
    #result {
      width: 100%;
      max-width: 700px;
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    .card {
      background: white;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
      transition: transform 0.2s;
    }
    .card:hover {
      transform: translateY(-5px);
    }
    mark {
      background-color: #f1c40f;
      padding: 2px 4px;
      border-radius: 4px;
    }
    .source {
      margin-top: 10px;
      font-size: 14px;
      color: #7f8c8d;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.12.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/universal-sentence-encoder@1.3.3/dist/universal-sentence-encoder.min.js"></script>
</head>
<body>

  <h1>‡∑É‡∑í‡∂Ç‡∑Ñ‡∂Ω ‡∂∂‡∑î‡∂Ø‡∑ä‡∂∞‡∑í‡∂∏‡∂≠‡∑ä ‡∑É‡∑ô‡∑Ä‡∑î‡∂∏</h1>

  <div id="search-box">
    <input type="text" id="query" placeholder="‡∂î‡∂∂‡∑ö ‡∂¥‡∑ä‚Äç‡∂ª‡∑Å‡∑ä‡∂±‡∂∫ ‡∂∫‡∑ú‡∂Ø‡∂±‡∑ä‡∂±...">
    <button onclick="search()">‡∑É‡∑ô‡∑Ä‡∑ì‡∂∏</button>
    <button onclick="startVoice()">üé§</button>
  </div>

  <div id="result"></div>

  <script>
    let data = [];
    let model;
    let embeddings = [];

    // Sinhala Synonym Dictionary
    const synonyms = {
      "‡∂±‡∑í‡∑Ä‡∂±‡∑ä": ["‡∂±‡∑í‡∑Ä‡∂±‡∑ä", "‡∂±‡∑í‡∑Ä‡∂±", "‡∂±‡∑í‡∂ª‡∑ù‡∂∞‡∂∫", "‡∑É‡∂±‡∑ä‡∑É‡∑î‡∂±", "‡∑É‡∂±‡∑ä‡∑É‡∑î‡∂±‡∑ä‡∂∑‡∑è‡∑Ä‡∂∫", "‡∂¥‡∑ä‚Äç‡∂ª‡∑Å‡∑ä‡∑Ä‡∑è‡∑É‡∂∫", "‡∑Å‡∑è‡∂±‡∑ä‡∂≠‡∑í", "‡∂¥‡∑ä‚Äç‡∂ª‡∑Å‡∑è‡∂±‡∑ä‡∂≠‡∑í", "‡∑É‡∂±‡∑ä‡∑É‡∑î‡∂±‡∑è‡∑Ä", "‡∑É‡∂±‡∑ä‡∑É‡∑î‡∂±‡∑í‡∂∫"],
      "‡∂Ø‡∑Ñ‡∂∏": ["‡∂Ø‡∑Ñ‡∂∏", "‡∂∞‡∂ª‡∑ä‡∂∏‡∂∫", "‡∂∞‡∂ª‡∑ä‡∂∏", "‡∂∞‡∂∏‡∑ä‡∂∏", "‡∂∞‡∂ª‡∑ä‡∂∏‡∂≠‡∑è", "‡∂∞‡∂ª‡∑ä‡∂∏ ‡∂Ø‡∑ö‡∑Å‡∂±‡∑è", "‡∂∞‡∂ª‡∑ä‡∂∏‡∑è‡∑Ä‡∂∂‡∑ù‡∂∞‡∂∫", "‡∂∞‡∂ª‡∑ä‡∂∏‡∂ú‡∑ä‚Äç‡∂ª‡∂±‡∑ä‡∂Æ‡∂∫"],
      "‡∂∂‡∑î‡∂Ø‡∑ä‡∂∞": ["‡∂∂‡∑î‡∂Ø‡∑ä‡∂∞", "‡∂∂‡∑î‡∂Ø‡∑î", "‡∂∂‡∑î‡∂Ø‡∑î‡∂±‡∑ä‡∑Ä‡∑Ñ‡∂±‡∑ä‡∑É‡∑ö", "‡∂∂‡∑î‡∂Ø‡∑ä‡∂∞‡∂∫‡∑è", "‡∂∂‡∑î‡∂Ø‡∑î‡∂ª‡∂¢‡∑è‡∂´‡∂±‡∑ä ‡∑Ä‡∑Ñ‡∂±‡∑ä‡∑É‡∑ö", "‡∑É‡∂∏‡∑ä‡∂∂‡∑î‡∂Ø‡∑î", "‡∑É‡∂ª‡∑ä‡∑Ä‡∂•"],
      "‡∑É‡∂Ç‡∑É‡∑è‡∂ª‡∂∫": ["‡∑É‡∂Ç‡∑É‡∑è‡∂ª‡∂∫", "‡∑É‡∂Ç‡∑É‡∑è‡∂ª", "‡∑É‡∂Ç‡∑É‡∑è‡∂ª ‡∂†‡∂ö‡∑ä‚Äç‡∂ª‡∂∫", "‡∂¢‡∑è‡∂≠‡∑í‡∂∏‡∂ª‡∂´‡∂∫", "‡∂∑‡∑Ä‡∂∫", "‡∂Ö‡∑Ä‡∑í‡∂†‡∑í", "‡∑É‡∂Ç‡∂†‡∑è‡∂ª‡∂∫"],
      "‡∂Ö‡∂±‡∑í‡∂†‡∑ä‡∂†": ["‡∂Ö‡∂±‡∑í‡∂†‡∑ä‡∂†", "‡∂Ö‡∂±‡∑í‡∂≠‡∑ä‚Äç‡∂∫", "‡∂Ö‡∂±‡∑í‡∂≠‡∑ä‚Äç‡∂∫‡∂≠‡∑è‡∑Ä", "‡∂Ö‡∂±‡∑í‡∂≠‡∑ä‚Äç‡∂∫‡∂∑‡∑è‡∑Ä‡∂∫", "‡∂Ö‡∑Ä‡∑í‡∂†‡∑ä‡∂†‡∑í", "‡∂¥‡∑ô‡∂Ω‡∑ô‡∂± ‡∑É‡∑ä‡∑Ä‡∂∑‡∑è‡∑Ä‡∂∫"],
      "‡∂Ø‡∑î‡∂ö‡∑ä‡∂õ": ["‡∂Ø‡∑î‡∂ö‡∑ä‡∂õ", "‡∂Ø‡∑î‡∂ö‡∑ä‡∂õ‡∂∫", "‡∂Ø‡∑î‡∂ö‡∑ä", "‡∂Ø‡∑î‡∂ö‡∑ä‡∂õ‡∂≠‡∑ä‡∑Ä‡∂∫", "‡∂¥‡∑ì‡∂©‡∑è", "‡∑Ä‡∑ô‡∂Ø‡∂±‡∑è", "‡∑É‡∑è‡∂ª‡∂ú‡∑ä‚Äç‡∂ª‡∑Ñ‡∂´‡∂∫", "‡∂Ö‡∑É‡∑è‡∂ª‡∂∑‡∑è‡∑Ä‡∂∫"],
      "‡∂Ö‡∂±‡∑è‡∂≠‡∑ä‡∂∏": ["‡∂Ö‡∂±‡∑è‡∂≠‡∑ä‡∂∏", "‡∂Ö‡∂±‡∂≠‡∑ä‡∂Æ", "‡∂Ö‡∂±‡∑è‡∂≠‡∑ä‡∂∏‡∂∑‡∑è‡∑Ä‡∂∫", "‡∂±‡∑í‡∑Å‡∑ä‡∂®‡∑í‡∂≠‡∂∑‡∑è‡∑Ä‡∂∫", "‡∂±‡∑í‡∂ª‡∑ä‡∂∏‡∂±‡∂∑‡∑è‡∑Ä‡∂∫"],
      "‡∑É‡∂Ø‡∑ä‡∂∞‡∑è": ["‡∑É‡∂Ø‡∑ä‡∂∞‡∑è", "‡∑Å‡∑ä‚Äç‡∂ª‡∂Ø‡∑ä‡∂∞‡∑è‡∑Ä", "‡∑Å‡∑ä‚Äç‡∂ª‡∂Ø‡∑ä‡∂∞‡∑è‡∑Ä‡∂±‡∑ä", "‡∑É‡∂Ø‡∑ä‡∂∞‡∑è‡∂∂‡∂Ω‡∂∫", "‡∑Ä‡∑í‡∑Å‡∑ä‡∑Ä‡∑è‡∑É‡∂∫"],
      "‡∑É‡∂∏‡∂Æ": ["‡∑É‡∂∏‡∂Æ", "‡∑É‡∂∏‡∑è‡∂∞‡∑í", "‡∂±‡∑í‡∑Ä‡∂±‡∑ä‡∑É‡∂∏‡∂Æ", "‡∑É‡∂±‡∑ä‡∑É‡∑î‡∂±‡∑ä‡∂∑‡∑è‡∑Ä‡∂∫", "‡∂±‡∑í‡∑Ä‡∂±‡∑ä‡∂ú‡∑è‡∂∏‡∑ì ‡∑É‡∂∏‡∑è‡∂∞‡∑í"],
      "‡∑Ä‡∑í‡∂¥‡∑É‡∑ä‡∑É‡∂±‡∑è": ["‡∑Ä‡∑í‡∂¥‡∑É‡∑ä‡∑É‡∂±‡∑è", "‡∑Ä‡∑í‡∂¥‡∑ä‡∂¥‡∑É‡∑ä‡∑É‡∂±‡∑è", "‡∑É‡∂≠‡∑í", "‡∑Ä‡∑í‡∑Ä‡∑ö‡∂ö‡∂∫", "‡∑É‡∂≠‡∑í‡∑É‡∂∏‡∑ä‡∂¥‡∂¢‡∑ä‡∂£‡∂±‡∑ä‚Äç‡∂∫"],
      "‡∑É‡∑ì‡∂Ω‡∂∫": ["‡∑É‡∑ì‡∂Ω‡∂∫", "‡∑É‡∑ì‡∂Ω", "‡∑É‡∑ì‡∂Ω ‡∑É‡∂∏‡∑ä‡∂¥‡∂≠‡∑ä", "‡∂Ö‡∂ª‡∑í‡∂∫ ‡∑É‡∑ì‡∂Ω‡∂∫", "‡∂∞‡∂ª‡∑ä‡∂∏‡∑É‡∑ì‡∂Ω"],
      "‡∂¥‡∂§‡∑ä‡∂§‡∑è": ["‡∂¥‡∂§‡∑ä‡∂§‡∑è", "‡∂¥‡∑ä‚Äç‡∂ª‡∂•‡∑è", "‡∑Ä‡∑í‡∑Ä‡∑ô‡∂ö", "‡∑É‡∂Ç‡∂∏‡∑è ‡∂Ü‡∂∫‡∑ù‡∂ú", "‡∂•‡∑è‡∂´‡∂∫"],
      "‡∂ö‡∂ª‡∑î‡∂±‡∑è": ["‡∂ö‡∂ª‡∑î‡∂±‡∑è", "‡∂ö‡∑è‡∑Ü‡∑î‡∂±‡∑è", "‡∂ö‡∑ò‡∂¥‡∑è‡∑Ä", "‡∂Ø‡∂∫‡∑è‡∑Ä"],
      "‡∂∏‡∑ô‡∂≠‡∑ä‡∂≠": ["‡∂∏‡∑ô‡∂≠‡∑ä‡∂≠", "‡∂∏‡∑ô‡∂≠‡∑ä‡∂≠‡∑è", "‡∂∏‡∑õ‡∂≠‡∑ä‚Äç‡∂ª‡∑ì", "‡∂∏‡∑õ‡∂≠‡∑ä‚Äç‡∂ª‡∑ì‡∂∑‡∑è‡∑Ä‡∂∫"],
      "‡∂∏‡∑î‡∂Ø‡∑í‡∂≠‡∑è": ["‡∂∏‡∑î‡∂Ø‡∑í‡∂≠‡∑è", "‡∂∏‡∑î‡∂Ø‡∑í‡∂≠‡∑è‡∑Ä", "‡∂¥‡∑ä‚Äç‡∂ª‡∑ì‡∂≠‡∑í‡∂∫", "‡∑É‡∂≠‡∑î‡∂ß‡∑î‡∂∑‡∑è‡∑Ä‡∂∫"],
      "‡∂Ü‡∂±‡∑î‡∑É‡∑É‡∑ä‡∑É‡∂≠‡∑í": ["‡∂Ü‡∂±‡∑î‡∑É‡∑É‡∑ä‡∑É‡∂≠‡∑í", "‡∂Ö‡∂±‡∑î‡∑É‡∑ä‡∂∏‡∂ª‡∂´", "‡∂Ö‡∂±‡∑î‡∑É‡∑ä‡∂∏‡∂ª‡∂´‡∂∫", "‡∑É‡∂≠‡∑í ‡∑É‡∂∏‡∑î‡∂Ø‡∂∫", "‡∑Ä‡∑í‡∑Ä‡∑ö‡∂ö ‡∑É‡∂≠‡∑í"],
      "‡∑É‡∂≠‡∑í": ["‡∑É‡∂≠‡∑í", "‡∑É‡∂≠‡∑í‡∑É‡∂∏‡∑ä‡∂¥‡∂¢‡∑ä‡∂£‡∂±‡∑ä‚Äç‡∂∫", "‡∑É‡∂≠‡∑í‡∑É‡∂Ç‡∂ú‡∑ä‚Äç‡∂ª‡∑Ñ‡∂∫"],
      "‡∂±‡∑í‡∂ª‡∑ù‡∂∞": ["‡∂±‡∑í‡∂ª‡∑ù‡∂∞", "‡∂±‡∑í‡∑Ä‡∂±‡∑ä", "‡∂±‡∑Ä‡∂∏ ‡∂Ö‡∂ª‡∂∏‡∑î‡∂´", "‡∂Ö‡∂ª‡∂∏‡∑î‡∂´‡∑î ‡∂¥‡∑ä‚Äç‡∂ª‡∑è‡∂¥‡∑ä‡∂≠‡∑í‡∂∫"],
      "‡∂∏‡∂ú": ["‡∂∏‡∂ú", "‡∂Ö‡∂ª‡∑í‡∂∫ ‡∂∏‡∂ú", "‡∂Ö‡∂ß‡∂ú‡∑í ‡∂∏‡∂ü", "‡∂Ö‡∑Ç‡∑ä‡∂ß‡∑è‡∂Ç‡∂ú‡∑í‡∂ö ‡∂∏‡∑è‡∂ª‡∑ä‡∂ú‡∂∫"],
      "‡∑É‡∂Ç‡∂õ‡∑è‡∂ª": ["‡∑É‡∂Ç‡∂õ‡∑è‡∂ª", "‡∑É‡∂Ç‡∂ö‡∂Ω‡∑ä‡∂¥", "‡∑É‡∂Ç‡∂õ‡∑è‡∂ª‡∂∫", "‡∑É‡∂Ç‡∑É‡∑è‡∂ª‡∑í ‡∑É‡∑ä‡∑Ä‡∂∑‡∑è‡∑Ä‡∂∫"],
      "‡∂¥‡∂ß‡∑í‡∂†‡∑ä‡∂†‡∑É‡∂∏‡∑î‡∂¥‡∑ä‡∂¥‡∑è‡∂Ø‡∂∫": ["‡∂¥‡∂ß‡∑í‡∂†‡∑ä‡∂†‡∑É‡∂∏‡∑î‡∂¥‡∑ä‡∂¥‡∑è‡∂Ø‡∂∫", "‡∂Ö‡∂±‡∑í‡∂†‡∑ä‡∂† ‡∑É‡∂Ç‡∂•‡∑è‡∑Ä", "‡∂±‡∑í‡∑Ä‡∂±‡∑ä ‡∑É‡∂Ç‡∂•‡∑è‡∑Ä", "‡∂±‡∑í‡∑Ä‡∂±‡∑ä‡∂ú‡∑è‡∂∏‡∑ì ‡∑É‡∂≠‡∑í"],
      "‡∂Ö‡∂ª‡∑ä‡∂∫ ‡∑É‡∂≠‡∑ä‚Äç‡∂∫‡∂∫": ["‡∂Ö‡∂ª‡∑ä‡∂∫ ‡∑É‡∂≠‡∑ä‚Äç‡∂∫‡∂∫", "‡∑É‡∂≠‡∑ä‚Äç‡∂∫‡∂∫", "‡∂Ö‡∂ª‡∑í‡∂∫ ‡∑É‡∂≠‡∑ä‚Äç‡∂∫‡∂∫", "‡∑É‡∂≠‡∂ª ‡∂Ö‡∂ª‡∑ä‡∂∫ ‡∑É‡∂≠‡∑ä‚Äç‡∂∫‡∂∫"],
      "‡∂±‡∑Ä ‡∑É‡∂±‡∑ä‡∑É‡∂±‡∑ä‡∂Ø‡∂±": ["‡∂±‡∑Ä ‡∑É‡∂±‡∑ä‡∑É‡∂±‡∑ä‡∂Ø‡∂±", "‡∂±‡∑Ä ‡∑É‡∂±‡∑ä‡∂∞‡∑è‡∂±‡∂∫", "‡∂±‡∑Ä ‡∂Ø‡∂ª‡∑ä‡∑Å‡∂±‡∂∫", "‡∂Ø‡∂ª‡∑ä‡∑Å‡∂±‡∑ì‡∂∫ ‡∑É‡∂±‡∑ä‡∂∞‡∑è‡∂±‡∂∫"]
    };

    async function loadAllFiles() {
      try {
        const response = await fetch('textfile/file-list.json');
        const textFiles = await response.json();
        const promises = textFiles.map(file =>
          fetch(file)
            .then(response => response.text())
            .then(text => text.split('\n').filter(line => line.trim() !== '').map(line => ({ text: line, source: file })))
        );
        const results = await Promise.all(promises);
        data = results.flat();
        console.log('All files loaded:', data.length, 'paragraphs.');
        await loadEmbeddings();
      } catch (error) {
        console.error('Error loading files:', error);
      }
    }

    loadAllFiles();

    async function loadEmbeddings() {
      try {
        model = await use.load();
        const sentences = data.map(d => d.text);
        const tensor = await model.embed(sentences);
        embeddings = await tensor.array();
        tensor.dispose();
        console.log('Embeddings computed:', embeddings.length);
      } catch (err) {
        console.error('Error loading embeddings:', err);
      }
    }

    function normalize(word) {
      return word.replace(/(‡∂∫‡∂±‡∑ä|‡∑Ä‡∂±‡∑ä|‡∂∫‡∂±‡∑ä‡∂ú‡∑ö|‡∂∫‡∂±‡∑ä‡∑Ä‡∑Ñ‡∂±‡∑ä‡∑É‡∑ö|‡∂Ω‡∑è|‡∂±‡∑ä|‡∂∫|‡∑Ä|‡∑Ö|‡∑É‡∑ö)?$/, '');
    }

    function tokenize(text) {
      return text
        .replace(/[.,?ÿõ‚Äú‚Äù"‚Äò‚Äô'()\[\]{}]/g, '')
        .split(/\s+/)
        .filter(Boolean)
        .map(normalize);
    }

    function expandSynonyms(words) {
      let expanded = [];
      words.forEach(word => {
        let found = false;
        for (const key in synonyms) {
          if (synonyms[key].includes(word)) {
            expanded = expanded.concat(synonyms[key]);
            found = true;
            break;
          }
        }
        if (!found) expanded.push(word);
      });
      return Array.from(new Set(expanded));
    }

    function cosineSimilarity(v1, v2) {
      let dot = 0, norm1 = 0, norm2 = 0;
      for (let i = 0; i < v1.length; i++) {
        dot += v1[i] * v2[i];
        norm1 += v1[i] * v1[i];
        norm2 += v2[i] * v2[i];
      }
      return dot / (Math.sqrt(norm1) * Math.sqrt(norm2));
    }

    async function search() {
      const query = document.getElementById('query').value.trim();
      if (!query) {
        document.getElementById('result').innerHTML = "<p>‡∂ö‡∂ª‡∑î‡∂´‡∑è‡∂ö‡∂ª ‡∂¥‡∑ä‚Äç‡∂ª‡∑Å‡∑ä‡∂±‡∂∫‡∂ö‡∑ä ‡∂∫‡∑ú‡∂Ø‡∂±‡∑ä‡∂±.</p>";
        return;
      }
      if (!model || embeddings.length === 0) {
        document.getElementById('result').innerHTML = "<p>‡∂Ø‡∂≠‡∑ä‡∂≠ ‡∂¥‡∑ñ‡∂ª‡∂´‡∂∫ ‡∑Ä‡∑ô‡∂∏‡∑í‡∂±‡∑ä...</p>";
        return;
      }

      const queryWords = expandSynonyms(tokenize(query));
      const queryText = queryWords.join(' ');
      const qTensor = await model.embed([queryText]);
      const qEmbed = (await qTensor.array())[0];
      qTensor.dispose();

      const scoredResults = embeddings.map((embed, idx) => ({
        ...data[idx],
        score: cosineSimilarity(qEmbed, embed)
      }));

      scoredResults.sort((a, b) => b.score - a.score);

      const topResults = scoredResults.slice(0, 5).filter(r => r.score > 0.2);

      if (topResults.length === 0) {
        document.getElementById('result').innerHTML = "<p>‡∂ö‡∑í‡∑É‡∑í‡∂Ø‡∑î ‡∂¥‡∑ä‚Äç‡∂ª‡∂≠‡∑í‡∂µ‡∂Ω‡∂∫‡∂ö‡∑ä ‡∂±‡∑ê‡∂≠.</p>";
        return;
      }

      document.getElementById('result').innerHTML = topResults.map(r => `
        <div class="card">
          ${highlight(r.text, queryWords)}
          <div class="source">‡∂∏‡∑ñ‡∂Ω‡∑è‡∑Å‡∑ä‚Äç‡∂ª‡∂∫: ${r.source}</div>
        </div>
      `).join('');
    }

    function highlight(text, queryWords) {
      queryWords.forEach(word => {
        const regex = new RegExp(`(${word})`, 'gi');
        text = text.replace(regex, '<mark>$1</mark>');
      });
      return text;
    }

    function startVoice() {
      const recognition = new webkitSpeechRecognition();
      recognition.lang = 'si-LK';
      recognition.start();
      recognition.onresult = function(event) {
        const query = event.results[0][0].transcript;
        document.getElementById('query').value = query;
        search();
      };
    }
  </script>
</body>
</html>
